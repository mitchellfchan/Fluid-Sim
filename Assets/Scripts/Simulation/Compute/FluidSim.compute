#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel Reorder
#pragma kernel ReorderCopyBack
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForce
#pragma kernel CalculateViscosity
#pragma kernel UpdatePositions
#pragma kernel UpdateDensityTexture
#pragma kernel UpdateWhiteParticles
#pragma kernel WhiteParticlePrepareNextFrame

// Includes
#include "./FluidMaths3D.hlsl"
#include "./SpatialHash3D.hlsl"

static const int ThreadGroupSize = 256;


// Buffers
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float3> PredictedPositions;
RWStructuredBuffer<float3> Velocities;
RWStructuredBuffer<float2> Densities; // Density, Near Density
RWStructuredBuffer<uint> ParticleIDs; // Persistent particle IDs (for consistent coloring)

// Spatial hashing
RWStructuredBuffer<uint> SpatialKeys;
RWStructuredBuffer<uint> SpatialOffsets;
StructuredBuffer<uint> SortedIndices;

RWStructuredBuffer<float3> Debug;

// Settings
const uint numParticles;
const float gravity;
const float deltaTime;
const float simTime;
const float collisionDamping;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
const float viscosityStrength;
const float edgeForce;
const float edgeForceDst;
const float3 boundsSize;

// Collision objects
struct GPUCollisionObject
{
    float3 position;             // 12 bytes
    float radius;                // 4 bytes
    
    float3 velocity;             // 12 bytes  
    int shapeType;               // 4 bytes (CollisionShape as int)
    
    float3 size;                 // 12 bytes
    float mass;                  // 4 bytes
    
    float bounciness;            // 4 bytes
    float friction;              // 4 bytes
    float enableMomentumTransfer; // 4 bytes (bool as float)
    float isActive;              // 4 bytes (bool as float)
    
    // Rotation and angular velocity support
    float4x4 rotationMatrix;    // 64 bytes - full transform matrix
    float3 angularVelocity;      // 12 bytes - rotation speed (radians/second)
    float3 rotationCenter;       // 12 bytes - true pivot point for rotation
    float padding;               // 4 bytes - keep 16-byte alignment
    // Total: 156 bytes
};

// Collision object buffer and settings
StructuredBuffer<GPUCollisionObject> CollisionObjects;
const uint numCollisionObjects;
const uint maxCollisionObjects;

// Shape type constants (must match C# CollisionShape enum)
static const int SHAPE_NONE = 0;
static const int SHAPE_SPHERE = 1;
static const int SHAPE_BOX = 2;
static const int SHAPE_CYLINDER = 3;
static const int SHAPE_CAPSULE = 4;
static const int SHAPE_COMPOSITE = 5;

// ===== FORCE ZONE SYSTEM =====
struct GPUForceZone
{
    float3 position;             // 12 bytes
    float radius;                // 4 bytes
    
    float3 forceDirection;       // 12 bytes
    int shapeType;               // 4 bytes (ForceZoneShape as int)
    
    float3 size;                 // 12 bytes
    int forceMode;               // 4 bytes (ForceZoneMode as int)
    
    float forceStrength;         // 4 bytes
    float isActive;              // 4 bytes (bool as float)
    float vortexTwist;           // 4 bytes
    float turbulenceFrequency;   // 4 bytes
    
    // Rotation support
    float4x4 rotationMatrix;    // 64 bytes
    float3 vortexAxis;           // 12 bytes
    float turbulenceOctaves;     // 4 bytes
    
    // Falloff curve sampling (8 samples)
    float4 falloffSamples0;      // 16 bytes (samples 0-3)
    float4 falloffSamples1;      // 16 bytes (samples 4-7)
    
    // Total: 176 bytes
};

// Force zone buffer and settings
StructuredBuffer<GPUForceZone> ForceZones;
const uint numForceZones;
const uint maxForceZones;

// Force mode constants (must match C# ForceZoneMode enum)
static const int FORCEMODE_NONE = 0;
static const int FORCEMODE_DIRECTIONAL = 1;
static const int FORCEMODE_RADIAL = 2;
static const int FORCEMODE_VORTEX = 3;
static const int FORCEMODE_TURBULENCE = 4;
static const int FORCEMODE_DIRECTIONAL_WITH_FALLOFF = 5;

const float4x4 localToWorld;
const float4x4 worldToLocal;

const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;



// Volume texture settings
RWTexture3D<float> DensityMap;
const uint3 densityMapSize;

// ---- Foam, spray, and bubbles ----
struct WhiteParticle
{
    float3 position;
    float3 velocity;
    float remainingLifetime;
    float scale;
};

RWStructuredBuffer<WhiteParticle> WhiteParticles;
RWStructuredBuffer<WhiteParticle> WhiteParticlesCompacted;
// Holds 2 values:
// [0] = ActiveCount: (num particles alive or spawned in at the start of the frame)
// [1] = SurvivorCount: (num particles surviving to the next frame -- copied into compact buffer)
RWStructuredBuffer<uint> WhiteParticleCounters;
const uint MaxWhiteParticleCount;
const float whiteParticleDeltaTime;

const float3 trappedAirParams;
const float2 kineticEnergyParams;
const float bubbleBuoyancy;
const int bubbleClassifyMinNeighbours;
const int sprayClassifyMaxNeighbours;
const float bubbleScale;
const float bubbleScaleChangeSpeed;

float PressureFromDensity(float density)
{
    return (density - targetDensity) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
    return nearDensity * nearPressureMultiplier;
}


float Remap01(float val, float minVal, float maxVal)
{
    return saturate((val - minVal) / (maxVal - minVal));
}

// ===== UNIFIED SDF FUNCTIONS =====

float SphereSDF(float3 pos, float3 center, float radius)
{
    return length(pos - center) - radius;
}

float BoxSDF(float3 pos, float3 center, float3 size)
{
    float3 d = abs(pos - center) - size * 0.5;
    return max(d.x, max(d.y, d.z));
}

float CapsuleSDF(float3 pos, float3 pointA, float3 pointB, float radius)
{
    float3 pa = pos - pointA;
    float3 ba = pointB - pointA;
    float h = saturate(dot(pa, ba) / dot(ba, ba));
    return length(pa - ba * h) - radius;
}

float CylinderSDF(float3 pos, float3 pointA, float3 pointB, float radius)
{
    float3 pa = pos - pointA;
    float3 ba = pointB - pointA;
    float h = dot(pa, ba) / dot(ba, ba); // No saturate - allows extending beyond caps
    
    // Distance to infinite cylinder axis
    float radialDist = length(pa - ba * h) - radius;
    
    // Distance to caps (flat ends)
    float capDist = abs(h - 0.5) - 0.5; // Distance beyond normalized height range
    capDist *= length(ba); // Scale back to world units
    
    // Combine: inside cylinder if both radial and cap distances are negative
    return max(radialDist, capDist);
}

// Calculate SDF distance for any collision object
float CalculateObjectSDF(float3 pos, GPUCollisionObject obj)
{
    if (obj.shapeType == SHAPE_SPHERE)
    {
        return SphereSDF(pos, obj.position, obj.radius);
    }
    else if (obj.shapeType == SHAPE_BOX)
    {
        // Transform position to box's local space
        // Since we're only using rotation (no scaling), transpose = inverse for rotation matrix
        float3 worldOffset = pos - obj.position;
        float3 localPos = mul(transpose((float3x3)obj.rotationMatrix), worldOffset);
        return BoxSDF(localPos, float3(0, 0, 0), obj.size);
    }
    else if (obj.shapeType == SHAPE_CYLINDER)
    {
        // For cylinder: size.x is height, radius is radius
        float height = obj.size.x;
        float halfHeight = height * 0.5;
        
        // Apply rotation to get properly oriented cylinder axis
        float3 localUp = mul((float3x3)obj.rotationMatrix, float3(0, 1, 0));
        float3 pointA = obj.position - localUp * halfHeight; // Bottom
        float3 pointB = obj.position + localUp * halfHeight; // Top
        return CylinderSDF(pos, pointA, pointB, obj.radius);
    }
    else if (obj.shapeType == SHAPE_CAPSULE)
    {
        // For capsule: size.x is TOTAL height (including hemisphere caps)
        // Cylinder height = totalHeight - 2*radius
        float totalHeight = obj.size.x;
        float cylinderHeight = max(0.0, totalHeight - 2.0 * obj.radius);
        float halfCylinderHeight = cylinderHeight * 0.5;
        
        // Apply rotation to get properly oriented capsule axis
        float3 localUp = mul((float3x3)obj.rotationMatrix, float3(0, 1, 0));
        float3 pointA = obj.position - localUp * halfCylinderHeight; // Bottom of cylinder
        float3 pointB = obj.position + localUp * halfCylinderHeight; // Top of cylinder
        return CapsuleSDF(pos, pointA, pointB, obj.radius);
    }
    // Add more shapes here in the future
    return 1000.0; // Far outside for unknown shapes
}

// Calculate surface normal for any collision object
float3 CalculateObjectNormal(float3 pos, GPUCollisionObject obj)
{
    if (obj.shapeType == SHAPE_SPHERE)
    {
        return normalize(pos - obj.position);
    }
    else if (obj.shapeType == SHAPE_BOX)
    {
        // Box normal calculation with rotation
        // Transform position to box's local space
        float3 worldOffset = pos - obj.position;
        float3 localPos = mul(transpose((float3x3)obj.rotationMatrix), worldOffset);
        float3 halfSize = obj.size * 0.5;
        float3 d = abs(localPos) - halfSize;
        
        // Find which face is closest in local space
        float3 localNormal;
        if (d.x > d.y && d.x > d.z) {
            localNormal = float3(sign(localPos.x), 0, 0);
        } else if (d.y > d.z) {
            localNormal = float3(0, sign(localPos.y), 0);
        } else {
            localNormal = float3(0, 0, sign(localPos.z));
        }
        
        // Transform normal back to world space
        return mul((float3x3)obj.rotationMatrix, localNormal);
    }
    else if (obj.shapeType == SHAPE_CYLINDER)
    {
        // Cylinder normal calculation with rotation
        float height = obj.size.x;
        float halfHeight = height * 0.5;
        
        // Apply rotation to get properly oriented cylinder axis
        float3 localUp = mul((float3x3)obj.rotationMatrix, float3(0, 1, 0));
        float3 pointA = obj.position - localUp * halfHeight; // Bottom
        float3 pointB = obj.position + localUp * halfHeight; // Top
        
        float3 pa = pos - pointA;
        float3 ba = pointB - pointA;
        float h = dot(pa, ba) / dot(ba, ba);
        
        // Check if we're hitting the caps or the curved surface
        if (h < 0.0)
        {
            // Bottom cap - normal points down along local axis
            return -localUp;
        }
        else if (h > 1.0)
        {
            // Top cap - normal points up along local axis
            return localUp;
        }
        else
        {
            // Curved surface - radial direction
            float3 closestPoint = pointA + ba * h;
            float3 radial = pos - closestPoint;
            return normalize(radial);
        }
    }
    else if (obj.shapeType == SHAPE_CAPSULE)
    {
        // Capsule normal calculation with rotation
        float totalHeight = obj.size.x;
        float cylinderHeight = max(0.0, totalHeight - 2.0 * obj.radius);
        float halfCylinderHeight = cylinderHeight * 0.5;
        
        // Apply rotation to get properly oriented capsule axis
        float3 localUp = mul((float3x3)obj.rotationMatrix, float3(0, 1, 0));
        float3 pointA = obj.position - localUp * halfCylinderHeight; // Bottom of cylinder
        float3 pointB = obj.position + localUp * halfCylinderHeight; // Top of cylinder
        
        float3 pa = pos - pointA;
        float3 ba = pointB - pointA;
        float h = saturate(dot(pa, ba) / dot(ba, ba));
        float3 closestPoint = pointA + ba * h;
        
        return normalize(pos - closestPoint);
    }
    return float3(0, 1, 0); // Default up normal
}

// Push particle to object surface
float3 PushToSurface(float3 pos, GPUCollisionObject obj, float3 normal)
{
    if (obj.shapeType == SHAPE_SPHERE)
    {
        return obj.position + normal * obj.radius;
    }
    else if (obj.shapeType == SHAPE_BOX)
    {
        // Transform position to box's local space (same as SDF calculation)
        float3 worldOffset = pos - obj.position;
        float3 localPos = mul(transpose((float3x3)obj.rotationMatrix), worldOffset);
        float3 halfSize = obj.size * 0.5;
        
        // Find closest point on box in local space
        float3 localClosest = clamp(localPos, -halfSize, halfSize);
        
        // Transform back to world space
        float3 worldClosest = mul((float3x3)obj.rotationMatrix, localClosest) + obj.position;
        
        return worldClosest + normal * 0.01; // Small offset
    }
    else if (obj.shapeType == SHAPE_CYLINDER)
    {
        // For cylinder, push to surface with rotation
        float height = obj.size.x;
        float halfHeight = height * 0.5;
        
        // Apply rotation to get properly oriented cylinder axis
        float3 localUp = mul((float3x3)obj.rotationMatrix, float3(0, 1, 0));
        float3 pointA = obj.position - localUp * halfHeight;
        float3 pointB = obj.position + localUp * halfHeight;
        
        float3 pa = pos - pointA;
        float3 ba = pointB - pointA;
        float h = dot(pa, ba) / dot(ba, ba);
        
        // Push based on which surface we're hitting
        if (h < 0.0)
        {
            // Bottom cap - push down along local axis
            return pointA - localUp * 0.01;
        }
        else if (h > 1.0)
        {
            // Top cap - push up along local axis
            return pointB + localUp * 0.01;
        }
        else
        {
            // Curved surface - push radially
            float3 closestPoint = pointA + ba * h;
            return closestPoint + normal * obj.radius;
        }
    }
    else if (obj.shapeType == SHAPE_CAPSULE)
    {
        // For capsule, push along the normal direction with rotation
        float totalHeight = obj.size.x;
        float cylinderHeight = max(0.0, totalHeight - 2.0 * obj.radius);
        float halfCylinderHeight = cylinderHeight * 0.5;
        
        // Apply rotation to get properly oriented capsule axis
        float3 localUp = mul((float3x3)obj.rotationMatrix, float3(0, 1, 0));
        float3 pointA = obj.position - localUp * halfCylinderHeight;
        float3 pointB = obj.position + localUp * halfCylinderHeight;
        
        float3 pa = pos - pointA;
        float3 ba = pointB - pointA;
        float h = saturate(dot(pa, ba) / dot(ba, ba));
        float3 closestPoint = pointA + ba * h;
        
        return closestPoint + normal * obj.radius;
    }
    return pos; // No change for unknown shapes
}

// ===== MODERN COLLISION RESOLUTION =====
void ResolveCollisions(inout float3 pos, inout float3 vel, float collisionDamping)
{
    // 1. Handle boundary collisions (existing code)
    float3 posLocal = mul(worldToLocal, float4(pos, 1)).xyz;
    float3 velocityLocal = mul(worldToLocal, float4(vel, 0)).xyz;

    const float3 halfSize = 0.5;
    const float3 edgeDst = halfSize - abs(posLocal);

    // Resolve boundary collisions
    if (edgeDst.x <= 0)
    {
        posLocal.x = halfSize.x * sign(posLocal.x);
        velocityLocal.x *= -1 * collisionDamping;
    }
    if (edgeDst.y <= 0)
    {
        posLocal.y = halfSize.y * sign(posLocal.y);
        velocityLocal.y *= -1 * collisionDamping;
    }
    if (edgeDst.z <= 0)
    {
        posLocal.z = halfSize.z * sign(posLocal.z);
        velocityLocal.z *= -1 * collisionDamping;
    }

    pos = mul(localToWorld, float4(posLocal, 1)).xyz;
    vel = mul(localToWorld, float4(velocityLocal, 0)).xyz;

    // 2. Handle collision objects (NEW UNIFIED SYSTEM)
    for (uint i = 0; i < numCollisionObjects; i++)
    {
        GPUCollisionObject obj = CollisionObjects[i];
        
        // Skip inactive objects
        if (obj.isActive < 0.5) continue;
        
        // Calculate distance to object
        float objDist = CalculateObjectSDF(pos, obj);
        
        if (objDist < 0) // Inside object
        {
            // Calculate surface normal
            float3 normal = CalculateObjectNormal(pos, obj);
            
            // Push particle to surface
            pos = PushToSurface(pos, obj, normal);
            
            // Apply physics (momentum transfer or simple bounce)
            if (obj.enableMomentumTransfer > 0.5)
            {
                // ===== REAL ROTATIONAL MOMENTUM TRANSFER =====
                
                // Calculate point velocity on rotating object surface using TRUE rotation center
                float3 relativePos = pos - obj.rotationCenter;  // Use correct pivot point!
                float3 rotationalVelocity = cross(obj.angularVelocity, relativePos);
                float3 totalObjectVelocity = obj.velocity + rotationalVelocity;
                
                // Use point-specific velocity for momentum transfer
                float3 relativeVel = vel - totalObjectVelocity;
                float relativeNormalVel = dot(relativeVel, normal);
                
                if (relativeNormalVel < 0) // Approaching surface
                {
                    float momentumTransfer = 2 * relativeNormalVel / (1 + obj.mass);
                    float3 velChange = normal * momentumTransfer;
                    vel = vel - velChange * obj.bounciness;
                }
            }
            else
            {
                // Simple: Static collision
                float velNormalMagnitude = dot(vel, normal);
                float3 velNormal = normal * velNormalMagnitude;
                float3 velTangential = vel - velNormal;
                
                if (velNormalMagnitude < 0) // Moving toward surface
                {
                    velNormal *= -1; // Reverse normal component
                }
                
                vel = velNormal * obj.bounciness + velTangential * obj.friction;
            vel = velNormal * obj.bounciness + velTangential * obj.friction;
        }
    }
}
}

// ===== FORCE ZONE HELPER FUNCTIONS =====

// Sample falloff curve using linear interpolation between the 8 baked samples
float SampleFalloffCurve(float t, GPUForceZone zone)
{
    t = saturate(t); // Clamp to [0, 1]
    float samplePos = t * 7.0; // Map to [0, 7]
    int index = floor(samplePos);
    float frac = samplePos - index;
    
    // Get the two samples to interpolate between
    float sample1, sample2;
    if (index < 4)
    {
        sample1 = zone.falloffSamples0[index];
        sample2 = (index < 3) ? zone.falloffSamples0[index + 1] : zone.falloffSamples1[0];
    }
    else
    {
        int idx = index - 4;
        sample1 = zone.falloffSamples1[idx];
        sample2 = (idx < 3) ? zone.falloffSamples1[idx + 1] : zone.falloffSamples1[3];
    }
    
    return lerp(sample1, sample2, frac);
}

// Simple 3D noise function for turbulence
float Noise3D(float3 p)
{
    float3 i = floor(p);
    float3 f = frac(p);
    f = f * f * (3.0 - 2.0 * f); // Smoothstep
    
    float n = i.x + i.y * 57.0 + i.z * 113.0;
    return lerp(
        lerp(lerp(frac(sin(n + 0.0) * 43758.5453),
                  frac(sin(n + 1.0) * 43758.5453), f.x),
             lerp(frac(sin(n + 57.0) * 43758.5453),
                  frac(sin(n + 58.0) * 43758.5453), f.x), f.y),
        lerp(lerp(frac(sin(n + 113.0) * 43758.5453),
                  frac(sin(n + 114.0) * 43758.5453), f.x),
             lerp(frac(sin(n + 170.0) * 43758.5453),
                  frac(sin(n + 171.0) * 43758.5453), f.x), f.y), f.z);
}

// Fractal Brownian Motion for turbulence
float3 Turbulence3D(float3 p, float frequency, float octaves)
{
    float3 result = float3(0, 0, 0);
    float amplitude = 1.0;
    float totalAmplitude = 0.0;
    
    for (int i = 0; i < (int)octaves; i++)
    {
        result.x += (Noise3D(p * frequency) - 0.5) * amplitude;
        result.y += (Noise3D(p * frequency + float3(100.0, 0.0, 0.0)) - 0.5) * amplitude;
        result.z += (Noise3D(p * frequency + float3(0.0, 100.0, 0.0)) - 0.5) * amplitude;
        
        totalAmplitude += amplitude;
        amplitude *= 0.5;
        frequency *= 2.0;
    }
    
    return result / totalAmplitude;
}

// Calculate force from a force zone at a given position
float3 CalculateForceZoneForce(float3 pos, GPUForceZone zone)
{
    // Skip inactive zones
    if (zone.isActive < 0.5) return float3(0, 0, 0);
    
    // Calculate distance to zone using SDF (reuse collision SDF functions)
    float dist = 1000.0;
    float normalizedDist = 1.0; // 0 at center, 1 at edge
    
    if (zone.shapeType == SHAPE_SPHERE)
    {
        dist = length(pos - zone.position);
        normalizedDist = saturate(dist / zone.radius);
        if (dist > zone.radius) return float3(0, 0, 0); // Outside zone
    }
    else if (zone.shapeType == SHAPE_BOX)
    {
        // Transform to box local space
        float3 worldOffset = pos - zone.position;
        float3 localPos = mul(transpose((float3x3)zone.rotationMatrix), worldOffset);
        float3 halfSize = zone.size * 0.5;
        
        // Check if inside box
        if (any(abs(localPos) > halfSize)) return float3(0, 0, 0);
        
        // Distance to nearest face
        float3 d = halfSize - abs(localPos);
        float minDist = min(d.x, min(d.y, d.z));
        float maxDimension = max(halfSize.x, max(halfSize.y, halfSize.z));
        normalizedDist = 1.0 - saturate(minDist / maxDimension);
    }
    else if (zone.shapeType == SHAPE_CYLINDER)
    {
        float height = zone.size.x;
        float halfHeight = height * 0.5;
        float3 localUp = mul((float3x3)zone.rotationMatrix, float3(0, 1, 0));
        float3 pointA = zone.position - localUp * halfHeight;
        float3 pointB = zone.position + localUp * halfHeight;
        
        float3 pa = pos - pointA;
        float3 ba = pointB - pointA;
        float h = dot(pa, ba) / dot(ba, ba);
        
        if (h < 0.0 || h > 1.0) return float3(0, 0, 0); // Outside caps
        
        float radialDist = length(pa - ba * h);
        if (radialDist > zone.radius) return float3(0, 0, 0); // Outside radius
        
        normalizedDist = saturate(radialDist / zone.radius);
    }
    
    // Sample falloff curve
    float falloff = SampleFalloffCurve(normalizedDist, zone);
    
    // Calculate force based on mode
    float3 force = float3(0, 0, 0);
    
    if (zone.forceMode == FORCEMODE_DIRECTIONAL || zone.forceMode == FORCEMODE_DIRECTIONAL_WITH_FALLOFF)
    {
        // Constant direction
        force = zone.forceDirection * zone.forceStrength;
    }
    else if (zone.forceMode == FORCEMODE_RADIAL)
    {
        // Push away from or pull toward center
        float3 dir = normalize(pos - zone.position);
        if (dist < 0.001) dir = float3(0, 1, 0); // Avoid division by zero at center
        force = dir * zone.forceStrength;
    }
    else if (zone.forceMode == FORCEMODE_VORTEX)
    {
        // Spinning motion around axis
        float3 toPoint = pos - zone.position;
        float3 axis = zone.vortexAxis;
        
        // Project point onto axis
        float3 axisPoint = axis * dot(toPoint, axis);
        float3 radialDir = toPoint - axisPoint; // Perpendicular to axis
        float radialDist = length(radialDir);
        
        if (radialDist > 0.001)
        {
            radialDir = normalize(radialDir);
            float3 tangentialDir = cross(axis, radialDir); // Direction of rotation
            
            // Combine tangential (spinning) with radial (twist)
            force = (tangentialDir + radialDir * zone.vortexTwist) * zone.forceStrength;
        }
    }
    else if (zone.forceMode == FORCEMODE_TURBULENCE)
    {
        // Chaotic noise-based force
        float3 turbulence = Turbulence3D(pos, zone.turbulenceFrequency, zone.turbulenceOctaves);
        force = turbulence * zone.forceStrength;
    }
    
    // Apply falloff
    return force * falloff;
}

[numthreads(ThreadGroupSize, 1, 1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    // External forces (gravity)
    Velocities[id.x] += float3(0, gravity, 0) * deltaTime;
    
    // ===== APPLY FORCE ZONES =====
    float3 pos = Positions[id.x];
    float3 totalForce = float3(0, 0, 0);
    
    for (uint i = 0; i < numForceZones; i++)
    {
        totalForce += CalculateForceZoneForce(pos, ForceZones[i]);
    }
    
    // Apply force zones as acceleration
    Velocities[id.x] += totalForce * deltaTime;

    // Predict
    PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * 1 / 120.0;
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdateSpatialHash(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    uint index = id.x;
    int3 cell = GetCell3D(PredictedPositions[index], smoothingRadius);
    uint hash = HashCell3D(cell);
    uint key = KeyFromHash(hash, numParticles);

    SpatialKeys[id.x] = key;
}


RWStructuredBuffer<float3> SortTarget_Positions;
RWStructuredBuffer<float3> SortTarget_PredictedPositions;
RWStructuredBuffer<float3> SortTarget_Velocities;
RWStructuredBuffer<uint> SortTarget_ParticleIDs;

[numthreads(ThreadGroupSize, 1, 1)]
void Reorder(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    uint sortedIndex = SortedIndices[id.x];
    SortTarget_Positions[id.x] = Positions[sortedIndex];
    SortTarget_PredictedPositions[id.x] = PredictedPositions[sortedIndex];
    SortTarget_Velocities[id.x] = Velocities[sortedIndex];
    SortTarget_ParticleIDs[id.x] = ParticleIDs[sortedIndex];
}

[numthreads(ThreadGroupSize, 1, 1)]
void ReorderCopyBack(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    Positions[id.x] = SortTarget_Positions[id.x];
    PredictedPositions[id.x] = SortTarget_PredictedPositions[id.x];
    Velocities[id.x] = SortTarget_Velocities[id.x];
    ParticleIDs[id.x] = SortTarget_ParticleIDs[id.x];
}

float2 CalculateDensitiesAtPoint(float3 pos)
{
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float density = 0;
    float nearDensity = 0;

    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius)
                continue;

            // Calculate density and near density
            float dst = sqrt(sqrDstToNeighbour);
            density += DensityKernel(dst, smoothingRadius);
            nearDensity += NearDensityKernel(dst, smoothingRadius);
        }
    }

    return float2(density, nearDensity);
}

[numthreads(ThreadGroupSize, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 pos = PredictedPositions[id.x];
    float2 densities = CalculateDensitiesAtPoint(pos);

    Densities[id.x] = densities;
}

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint state)
{
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result;
}

float RandomValue(inout uint state)
{
    return NextRandom(state) / 4294967295.0; // 2^32 - 1
}

// Thanks to https://math.stackexchange.com/a/4112622
// Calculates arbitrary normalized vector that is perpendicular to the given direction
float3 CalculateOrthonormal(float3 dir)
{
    float a = sign((sign(dir.x) + 0.5) * (sign(dir.z) + 0.5));
    float b = sign((sign(dir.y) + 0.5) * (sign(dir.z) + 0.5));
    float3 orthoVec = float3(a * dir.z, b * dir.z, -a * dir.x - b * dir.y);
    return normalize(orthoVec);
}


[numthreads(ThreadGroupSize, 1, 1)]
void CalculatePressureForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    // Calculate pressure
    float density = Densities[id.x][0];
    float densityNear = Densities[id.x][1];
    float pressure = PressureFromDensity(density);
    float nearPressure = NearPressureFromDensity(densityNear);
    float3 pressureForce = 0;
    float3 velocity = Velocities[id.x];

    float3 pos = PredictedPositions[id.x];
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    int neighbourCount = 0;

    // Foam variables
    float weightedVelocityDifference = 0;


    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            // Skip if looking at self
            if (neighbourIndex == id.x) continue;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key) break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;

            // Calculate pressure force
            float densityNeighbour = Densities[neighbourIndex][0];
            float nearDensityNeighbour = Densities[neighbourIndex][1];
            float neighbourPressure = PressureFromDensity(densityNeighbour);
            float neighbourPressureNear = NearPressureFromDensity(nearDensityNeighbour);

            float sharedPressure = (pressure + neighbourPressure) / 2;
            float sharedNearPressure = (nearPressure + neighbourPressureNear) / 2;

            float dstToNeighbour = sqrt(sqrDstToNeighbour);
            float3 dirToNeighbour = dstToNeighbour > 0 ? offsetToNeighbour / dstToNeighbour : float3(0, 1, 0);
            neighbourCount++;

            // Update pressure force
            pressureForce += dirToNeighbour * DensityDerivative(dstToNeighbour, smoothingRadius) * sharedPressure / densityNeighbour;
            pressureForce += dirToNeighbour * NearDensityDerivative(dstToNeighbour, smoothingRadius) * sharedNearPressure / nearDensityNeighbour;

            // ---- White Particle 'Trapped Air' Calculation ----
            float3 relativeVelocity = velocity - Velocities[neighbourIndex];
            float relativeVelocityMagnitude = length(relativeVelocity);
            float3 relativeVelocityDir = relativeVelocity / max(0.000001, relativeVelocityMagnitude);
            // 0 if moving in opposite directions; up to 2 if moving directly toward one another
            float convergeWeight = 1 - dot(relativeVelocityDir, -dirToNeighbour);
            // 1 when distance between particles is 0, down to 0 when distance reaches the smoothing radius
            float influence = 1 - min(1, dstToNeighbour / smoothingRadius);
            // Sum up weighted velocity diff between current particle and each of its surrounding neighbours
            weightedVelocityDifference += relativeVelocityMagnitude * convergeWeight * influence;
        }
    }

    float3 acceleration = pressureForce / density;
    float3 velocityNew = velocity + acceleration * deltaTime;
    Velocities[id.x] = velocityNew;

    // Quick test -- apply some drag to airborne fluid particles
    if (neighbourCount < 8)
    {
        Velocities[id.x] -= Velocities[id.x] * deltaTime * 0.75;
    }


    // ---- Handle spawning of white particles from the current fluid particle ----
    uint rngState = dot(asuint(float4(pos, simTime)), uint4(19349669, 83492837, 73856131, 4785773));
    if (id.x == 0) WhiteParticleCounters[1] = 0; // Reset survivor counter

    float trappedAirFactor = trappedAirParams[0] * Remap01(weightedVelocityDifference, trappedAirParams[1], trappedAirParams[2]);
    float kineticEnergyFactor = Remap01(dot(velocity, velocity), kineticEnergyParams[0], kineticEnergyParams[1]);
    float particleSpawnFactor = trappedAirFactor * kineticEnergyFactor * deltaTime;

    // Determine number of white particles to spawn. For example if the spawn factor is 3.7
    // then we will spawn at least 3 particles, with a 70% chance of spawning a 4th particle
    int particleSpawnCount = floor(particleSpawnFactor);
    float fractionalSpawnRemainder = particleSpawnFactor - particleSpawnCount;
    if (RandomValue(rngState) < fractionalSpawnRemainder) particleSpawnCount += 1;

    //uint targ = NextRandom(rngState) % 4096;

    //InterlockedAdd(WhiteParticleCounters[targ], 1);

    if (particleSpawnCount > 0)
    {
        uint particleIndex;
        InterlockedAdd(WhiteParticleCounters[0], (uint)particleSpawnCount, particleIndex);
        particleSpawnCount = min(particleSpawnCount, MaxWhiteParticleCount - particleIndex - 1);

        float3 cylinderBase = pos;
        float3 cylinderTop = pos + velocityNew * deltaTime; // height of cylinder determined by fluid velocity
        float3 cylinderAxisA = CalculateOrthonormal(velocityNew); // arbitrary direction along base of cylinder
        float3 cylinderAxisB = normalize(cross(cylinderAxisA, velocityNew));
        float cylinderRadius = smoothingRadius;
        float clusterMin, clusterMax;
        for (int spawnIndex = 0; spawnIndex < particleSpawnCount; spawnIndex++)
        {
            float randomAngle = RandomValue(rngState) * 2 * 3.1415;
            float3 offsetDir = cos(randomAngle) * cylinderAxisA + sin(randomAngle) * cylinderAxisB;
            float3 baseOffset = sqrt(RandomValue(rngState)) * cylinderRadius * offsetDir; // random point on cylinder base
            float3 spawnPos = cylinderBase + baseOffset + (cylinderTop - cylinderBase) * RandomValue(rngState);

            float dissolveTimeMin = 5;
            float dissolveTimeMax = 15;
            float lifetime = lerp(dissolveTimeMin, dissolveTimeMax, RandomValue(rngState));

            // Spawn new particle
            WhiteParticle whiteParticle;
            whiteParticle.position = spawnPos;
            whiteParticle.velocity = velocityNew + baseOffset;
            whiteParticle.remainingLifetime = lifetime;
            whiteParticle.scale = (bubbleScale + 1) / 2;
            WhiteParticles[particleIndex + spawnIndex] = whiteParticle;
        }
    }
}

[numthreads(ThreadGroupSize, 1, 1)]
void CalculateViscosity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 pos = PredictedPositions[id.x];
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;

    float3 viscosityForce = 0;
    float3 velocity = Velocities[id.x];

    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;


            // Skip if looking at self
            if (neighbourIndex == id.x)
                continue;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius)
                continue;

            // Calculate viscosity
            float dst = sqrt(sqrDstToNeighbour);
            float3 neighbourVelocity = Velocities[neighbourIndex];
            viscosityForce += (neighbourVelocity - velocity) * SmoothingKernelPoly6(dst, smoothingRadius);
        }
    }
    Velocities[id.x] += viscosityForce * viscosityStrength * deltaTime;
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 vel = Velocities[id.x];
    float3 pos = Positions[id.x];
    pos += vel * deltaTime;

    ResolveCollisions(pos, vel, collisionDamping);

    // Write results
    Positions[id.x] = pos;
    Velocities[id.x] = vel;
}

[numthreads(8, 8, 8)]
void UpdateDensityTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= densityMapSize.x || id.y >= densityMapSize.y || id.z >= densityMapSize.z)
        return;

    // Convert threadID to a world-space position, and sample the fluid density at that point
    float3 texturePos = id / (densityMapSize - 1.0);
    float3 worldPos = (texturePos - 0.5) * boundsSize;
    DensityMap[id] = CalculateDensitiesAtPoint(worldPos)[0];
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdateWhiteParticles(uint3 id : SV_DispatchThreadID)
{
    // Early exit if thread index exceeds particle count
    if (id.x >= min(MaxWhiteParticleCount, WhiteParticleCounters[0])) return;

    // Update particle
    float deltaTime = whiteParticleDeltaTime;
    WhiteParticle particle = WhiteParticles[id.x];

    // -- Neighbour fluid partices ---
    int3 originCell = GetCell3D(particle.position, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    int neighbourCount = 0;
    float3 velocitySum = 0;
    float weightSum = 0;

    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - particle.position;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            if (sqrDstToNeighbour < sqrRadius)
            {
                float dstToNeighbour = sqrt(sqrDstToNeighbour);
                float influenceWeight = SmoothingKernelPoly6(dstToNeighbour, smoothingRadius);

                // Add up velocities of nearby fluid particles, weighted smoothly by distance.
                // Also add up the weights so that we can compute the average fluid velocity.
                velocitySum += Velocities[neighbourIndex] * influenceWeight;
                weightSum += influenceWeight;

                neighbourCount += 1;
            }
        }
    }

    // -- Classify --
    bool isSpray = neighbourCount <= sprayClassifyMaxNeighbours;
    bool isBubble = neighbourCount >= bubbleClassifyMinNeighbours;
    bool isFoam = !(isSpray || isBubble);

    // Foam is transported by the fluid
    if (isFoam)
    {
        // We want the foam to be carried by the fluid (not just accelerated by it),
        // so the velocity is directly set to the average velocity of surrounding fluid.
        particle.velocity = velocitySum / weightSum;
        // Dissolve the foam over time
        particle.remainingLifetime -= deltaTime;
    }
    // Bubbles are accelerated by the surrounding fluid, and moved upwards due to buoyancy
    else if (isBubble)
    {
        const float fluidAccelMul = 3; // How fast the bubble accelerates to match velocity with fluid
        float3 accelerationBuoyancy = float3(0, gravity, 0) * (1 - bubbleBuoyancy);
        float3 accelerationFluid = (velocitySum / weightSum - particle.velocity) * fluidAccelMul;
        particle.velocity += (accelerationBuoyancy + accelerationFluid) * deltaTime;
    }
    // Spray is affected by gravity and drag
    else if (isSpray)
    {
        const float dragMultiplier = 0.04;
        float sqrSpeed = dot(particle.velocity, particle.velocity);
        float3 drag = -normalize(particle.velocity) * sqrSpeed * dragMultiplier;
        particle.velocity += (float3(0, gravity, 0) + drag) * deltaTime;
    }

    float targetScale = isBubble ? bubbleScale : 1;
    particle.scale = lerp(particle.scale, targetScale, deltaTime * bubbleScaleChangeSpeed);
    particle.position += particle.velocity * deltaTime;

    const float collisionDampening = 0.1;
    ResolveCollisions(particle.position, particle.velocity, collisionDampening);
    WhiteParticles[id.x] = particle;

    // Compact the surviving particles into temporary buffer
    if (particle.remainingLifetime > 0)
    {
        uint survivorIndex;
        InterlockedAdd(WhiteParticleCounters[1], 1, survivorIndex);
        WhiteParticlesCompacted[survivorIndex] = particle;
    }
}


[numthreads(ThreadGroupSize, 1, 1)]
void WhiteParticlePrepareNextFrame(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= MaxWhiteParticleCount) return;

    // Copy the surviving particles back into the main particle buffer
    if (id.x < WhiteParticleCounters[1])
    {
        WhiteParticles[id.x] = WhiteParticlesCompacted[id.x];
    }

    // Set active particle count to the survivor count
    if (id.x == 0)
    {
        WhiteParticleCounters[0] = WhiteParticleCounters[1];
    }
}
